using API;
using PxStat.Template;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Dynamic;
using System.Linq;

namespace PxStat.Security
{

    /// <summary>
    /// Read database performance entries generated by the application
    /// </summary>
    internal class Performance_BSO_ReadPrfRequestQueue : BaseTemplate_Read<Performance_DTO_Read, Performance_VLD_Read>
    {
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="request"></param>
        internal Performance_BSO_ReadPrfRequestQueue(JSONRPC_API request) : base(request, new Performance_VLD_Read())
        { }

        /// <summary>
        /// Test Privilege
        /// </summary>
        /// <returns></returns>
        override protected bool HasPrivilege()
        {
            return IsAdministrator();
        }

        /// <summary>
        /// Execute
        /// </summary>
        /// <returns></returns>
        protected override bool Execute()
        {
            List<string> serverList = new List<string>();
            List<DateTime> dateTime = new List<DateTime>();

            // Dictionary to hold the results coming from the database
            Dictionary<string, IndividualResults> dataCollection = new Dictionary<string, IndividualResults>();

            double interval = 1; //interval for timestamps
            // Dictionary to hold the server and array of results
            Dictionary<string, string[]> serverResultCollection = new Dictionary<string, string[]>();
            // Database read and result
            Performance_ADO adoPerformance = new Performance_ADO();

            ADO_readerOutput result = adoPerformance.Read(Ado, DTO.PrfDatetimeStart, DTO.PrfDatetimeEnd);
            if (!result.hasData)
            {
                //Declare and construct the empty output object
                dynamic output = new ExpandoObject();

                output.datetime = new List<string>();
                output.server = new List<string>();

                Response.data = output;


                return true;
            }
            else
            {
                // create list of timestamps between PrfDatetimeStart start and PrfDatetimeEnd
                DateTime starting = DTO.PrfDatetimeStart;
                DateTime ending = DTO.PrfDatetimeEnd;
                for (DateTime ts = starting; ts <= ending; ts = ts.AddMinutes(interval))
                {
                    dateTime.Add(ts.AddTicks(-(ts.Ticks % TimeSpan.TicksPerMinute)));
                }
                // List containing results.data values
                List<dynamic> myData = result.data;

                // Cycle through and add required elements to dataCollection Dictionary
                foreach (dynamic element in myData)
                {

                    if (!serverList.Contains(element.PrfServer))
                    {
                        serverList.Add(element.PrfServer);
                    }
                    IndividualResults tempResults = new IndividualResults();
                    tempResults.Datetime = element.PrfDatetime;
                    tempResults.ServerValue = element.PrfServer;
                    // Retrieve data from the PrfQueue column
                    tempResults.DataValue = element.PrfQueue;
                    dataCollection.Add(element.PrfServer + element.PrfDatetime, tempResults);
                }


                // use the server list to construct an array
                string[] serverArray = new string[serverList.Count];
                serverArray = serverList.ToArray();


                List<string> dateString = dateTime.Select(dt => dt.ToString()).ToList();

                for (int i = 0; i < serverList.Count; i++)
                {
                    string[] serverTotals = new string[dateTime.Count];
                    for (int j = 0; j < dateTime.Count; j++)
                    {
                        foreach (var item in dataCollection)
                        {
                            if ((item.Value.ServerValue.ToString() == serverList[i]) && (item.Value.Datetime == dateTime[j]))
                            {
                                serverTotals[j] = item.Value.DataValue.ToString();
                                break;
                            }
                            else
                                serverTotals[j] = null;
                        }
                    }
                    serverResultCollection.Add(serverArray[i], serverTotals);
                }

                // Convert Dictionary to IEnumerable
                IEnumerable serverResults = serverResultCollection.Select(p => new Dictionary<string, string[]>() { { p.Key, p.Value } });
                //Declare and construct the output object
                dynamic output = new ExpandoObject();

                output.datetime = dateString;
                output.server = serverResults;

                Response.data = output;



                return true;
            }
        }
    }

}
